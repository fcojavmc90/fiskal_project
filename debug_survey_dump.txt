==============================
PROJECT TREE (src - L4)
==============================
src
├── amplify-config.ts
├── amplifyconfiguration.json
├── amplify.ts
├── API.ts
├── app
│   ├── api
│   │   ├── cases
│   │   │   └── [caseId]
│   │   └── documents
│   │       ├── presign-download
│   │       └── presign-upload
│   ├── case-documents
│   │   └── page.tsx
│   ├── checkout
│   │   ├── case-deposit
│   │   ├── case-final
│   │   └── first-consult
│   │       └── page.tsx
│   ├── components
│   │   └── RequireAuth.tsx
│   ├── confirm
│   │   └── page.tsx
│   ├── dashboard
│   │   ├── admin
│   │   ├── admin~
│   │   ├── client
│   │   └── pro
│   ├── favicon.ico
│   ├── globals.css
│   ├── layout.tsx
│   ├── login
│   │   └── page.tsx
│   ├── page.module.css
│   ├── page.tsx
│   ├── page.tsx.save
│   ├── professionals
│   │   ├── [id]
│   │   │   └── page.tsx
│   │   └── page.tsx
│   ├── providers.tsx
│   ├── register
│   │   └── page.tsx
│   ├── schedule
│   │   └── page.tsx
│   └── survey
│       └── page.tsx
├── aws-exports.js
├── components
│   ├── AuthGate.tsx
│   ├── AuthProvider.tsx
│   ├── case
│   │   ├── AttachDocumentModal.tsx
│   │   └── CaseDocumentsModule.tsx
│   ├── Navbar.tsx
│   ├── Sidebar.tsx
│   ├── surveys
│   │   └── NoticeSurvey20Form.tsx
│   └── ui
│       ├── FiskalBadge.tsx
│       ├── FiskalButton.tsx
│       ├── FiskalCard.tsx
│       └── FiskalModal.tsx
├── graphql
│   ├── mutations.ts
│   ├── queries.ts
│   ├── schema.json
│   └── subscriptions.ts
└── lib
    ├── amplifyClient.ts
    ├── client
    │   └── documentsApi.ts
    ├── dynamoClient.ts
    ├── guards
    │   ├── requireSurvey.ts
    │   └── useRequireSurvey.ts
    ├── server
    │   └── s3.ts
    └── surveys
        ├── noticeSurvey20.ts
        └── noticeSurveyScoring.ts

36 directories, 45 files

==============================
AMPLIFY GRAPHQL SCHEMA
==============================

enum UserRole {
  CLIENT
  PRO
}

enum ProType {
  TAX
  LEGAL
  OTHER
}

enum AppointmentStatus {
  REQUESTED
  ACCEPTED
  REJECTED
  RESCHEDULE_PROPOSED
  CANCELLED
  COMPLETED
}

enum CaseStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum DocStatus {
  REQUESTED
  UPLOADED
  IN_REVIEW
  APPROVED
  REJECTED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum PaymentType {
  UNLOCK_150
  SERVICE_50_FIRST
  SERVICE_50_FINAL
}

type UserProfile
  @model
  @auth(rules: [{ allow: owner, ownerField: "owner", operations: [create, read, update] }]) {
  id: ID!
  owner: String!
  role: UserRole!
  email: AWSEmail
  firstName: String
  lastName: String
}

type ProfessionalProfile
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "owner", operations: [create, read, update] }
      { allow: private, operations: [read] }
    ]
  ) {
  id: ID!
  owner: String!
  proType: ProType!
  displayName: String!
  bio: String
  ratingAvg: Float
  ratingCount: Int
  isActive: Boolean
}

type SurveyResponse
  @model
  @auth(rules: [{ allow: owner, ownerField: "owner", operations: [create, read, update] }]) {
  id: ID!
  owner: String!
  answersJson: AWSJSON!
}

type Appointment
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "clientOwner", operations: [create, read] }
      { allow: owner, ownerField: "proOwner", operations: [read, update] }
    ]
  ) {
  id: ID!
  clientOwner: String!
  proOwner: String!
  professionalId: ID!
  requestedStart: AWSDateTime!
  requestedEnd: AWSDateTime!
  status: AppointmentStatus!
  proposedStart: AWSDateTime
  proposedEnd: AWSDateTime
  notes: String
  caseId: ID
}

type Case
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "clientOwner", operations: [create, read] }
      { allow: owner, ownerField: "proOwner", operations: [read, update] }
    ]
  ) {
  id: ID!
  caseNumber: String!
  clientOwner: String!
  proOwner: String!
  professionalId: ID!
  appointmentId: ID!
  status: CaseStatus!
}

type CaseDocument
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "clientOwner", operations: [create, read, update] }
      { allow: owner, ownerField: "proOwner", operations: [read, update] }
    ]
  ) {
  id: ID!
  caseId: ID! @index(name: "byCase", sortKeyFields: ["createdAt"])
  caseNumber: String!
  clientOwner: String!
  proOwner: String!
  professionalId: ID!
  title: String!
  required: Boolean
  status: DocStatus!
  fileName: String
  fileType: String
  s3Key: String
  uploadedAt: AWSDateTime
  reviewNotes: String
  createdAt: AWSDateTime
}

type Payment
  @model
  @auth(
    rules: [
      { allow: owner, ownerField: "clientOwner", operations: [create, read] }
      { allow: owner, ownerField: "proOwner", operations: [read] }
    ]
  ) {
  id: ID!
  clientOwner: String!
  proOwner: String
  professionalId: ID
  appointmentId: ID
  caseId: ID
  type: PaymentType!
  amountCents: Int!
  currency: String!
  status: PaymentStatus!
  squareCheckoutId: String
  squarePaymentId: String
}

==============================
API.ts - CreateSurveyResponseInput
==============================
201:export type CreateSurveyResponseInput = {
1054:  input: CreateSurveyResponseInput,

/* tslint:disable */
/* eslint-disable */
//  This file was automatically generated and should not be edited.

export type CreateUserProfileInput = {
  id?: string | null,
  owner: string,
  role: UserRole,
  email?: string | null,
  firstName?: string | null,
  lastName?: string | null,
};

export enum UserRole {
  CLIENT = "CLIENT",
  PRO = "PRO",
}


export type ModelUserProfileConditionInput = {
  owner?: ModelStringInput | null,
  role?: ModelUserRoleInput | null,
  email?: ModelStringInput | null,
  firstName?: ModelStringInput | null,
  lastName?: ModelStringInput | null,
  and?: Array< ModelUserProfileConditionInput | null > | null,
  or?: Array< ModelUserProfileConditionInput | null > | null,
  not?: ModelUserProfileConditionInput | null,
  createdAt?: ModelStringInput | null,
  updatedAt?: ModelStringInput | null,
};

export type ModelStringInput = {
  ne?: string | null,
  eq?: string | null,
  le?: string | null,
  lt?: string | null,
  ge?: string | null,
  gt?: string | null,
  contains?: string | null,
  notContains?: string | null,
  between?: Array< string | null > | null,
  beginsWith?: string | null,
  attributeExists?: boolean | null,
  attributeType?: ModelAttributeTypes | null,
  size?: ModelSizeInput | null,
};

export enum ModelAttributeTypes {
  binary = "binary",
  binarySet = "binarySet",
  bool = "bool",
  list = "list",
  map = "map",
  number = "number",
  numberSet = "numberSet",
  string = "string",
  stringSet = "stringSet",
  _null = "_null",
}


export type ModelSizeInput = {
  ne?: number | null,
  eq?: number | null,
  le?: number | null,
  lt?: number | null,
  ge?: number | null,
  gt?: number | null,
  between?: Array< number | null > | null,
};

export type ModelUserRoleInput = {
  eq?: UserRole | null,
  ne?: UserRole | null,
};

export type UserProfile = {
  __typename: "UserProfile",
  id: string,
  owner: string,
  role: UserRole,
  email?: string | null,
  firstName?: string | null,
  lastName?: string | null,
  createdAt: string,
  updatedAt: string,
};

export type UpdateUserProfileInput = {
  id: string,
  owner?: string | null,
  role?: UserRole | null,
  email?: string | null,
  firstName?: string | null,
  lastName?: string | null,
};

export type DeleteUserProfileInput = {
  id: string,
};

export type CreateProfessionalProfileInput = {
  id?: string | null,
  owner: string,
  proType: ProType,
  displayName: string,
  bio?: string | null,
  ratingAvg?: number | null,
  ratingCount?: number | null,
  isActive?: boolean | null,
};

export enum ProType {
  TAX = "TAX",
  LEGAL = "LEGAL",
  OTHER = "OTHER",
}


export type ModelProfessionalProfileConditionInput = {
  owner?: ModelStringInput | null,
  proType?: ModelProTypeInput | null,
  displayName?: ModelStringInput | null,
  bio?: ModelStringInput | null,
  ratingAvg?: ModelFloatInput | null,
  ratingCount?: ModelIntInput | null,
  isActive?: ModelBooleanInput | null,
  and?: Array< ModelProfessionalProfileConditionInput | null > | null,
  or?: Array< ModelProfessionalProfileConditionInput | null > | null,
  not?: ModelProfessionalProfileConditionInput | null,
  createdAt?: ModelStringInput | null,
  updatedAt?: ModelStringInput | null,
};

export type ModelProTypeInput = {
  eq?: ProType | null,
  ne?: ProType | null,
};

export type ModelFloatInput = {
  ne?: number | null,
  eq?: number | null,
  le?: number | null,
  lt?: number | null,
  ge?: number | null,
  gt?: number | null,
  between?: Array< number | null > | null,
  attributeExists?: boolean | null,
  attributeType?: ModelAttributeTypes | null,
};

export type ModelIntInput = {
  ne?: number | null,
  eq?: number | null,
  le?: number | null,
  lt?: number | null,
  ge?: number | null,
  gt?: number | null,
  between?: Array< number | null > | null,
  attributeExists?: boolean | null,
  attributeType?: ModelAttributeTypes | null,
};

export type ModelBooleanInput = {
  ne?: boolean | null,
  eq?: boolean | null,
  attributeExists?: boolean | null,
  attributeType?: ModelAttributeTypes | null,
};

export type ProfessionalProfile = {
  __typename: "ProfessionalProfile",
  id: string,
  owner: string,
  proType: ProType,
  displayName: string,
  bio?: string | null,
  ratingAvg?: number | null,
  ratingCount?: number | null,
  isActive?: boolean | null,
  createdAt: string,
  updatedAt: string,
};

export type UpdateProfessionalProfileInput = {
  id: string,
  owner?: string | null,
  proType?: ProType | null,
  displayName?: string | null,
  bio?: string | null,
  ratingAvg?: number | null,
  ratingCount?: number | null,
  isActive?: boolean | null,
};

export type DeleteProfessionalProfileInput = {
  id: string,
};


==============================
NoticeSurvey20Form.tsx (saveSurvey section)
==============================
      try {
        await getCurrentUser();
      } catch {
        setMsg("Debes iniciar sesión para guardar la encuesta.");
        return;
      }

      const scoring = scoreNoticeSurvey(answers);

      // Tu schema NO tiene campos computed/version, así que todo va dentro de answersJson
      const payload = {
        version: NOTICE_SURVEY_VERSION,
        answers,
        computed: scoring,
      };

      const answersJson = JSON.stringify(payload);
      if (!answersJson) throw new Error("answersJson quedó vacío.");

      const idKey = "fiskal:surveyResponseId:notice20";
      const existingId =
        typeof window !== "undefined" ? localStorage.getItem(idKey) : null;

      console.log("SAVE_SURVEY_PAYLOAD", {
        hasExistingId: Boolean(existingId),
        answersJsonLength: answersJson.length,
      });

      if (existingId) {
        const res: any = await client.graphql({
          query: UPDATE_SURVEY_RESPONSE,
          variables: { input: { id: existingId, answersJson } },
          authMode: "userPool",
        });

        if (res?.errors?.length) {
          throw new Error(res.errors.map((x: any) => x.message).join(" | "));
        }
      } else {
        const res: any = await client.graphql({
          query: CREATE_SURVEY_RESPONSE,
          variables: { input: { answersJson } },
          authMode: "userPool",
        });

        if (res?.errors?.length) {
          throw new Error(res.errors.map((x: any) => x.message).join(" | "));
        }

        const newId = res?.data?.createSurveyResponse?.id;
        if (!newId) throw new Error("createSurveyResponse no devolvió id.");

        if (typeof window !== "undefined") {
          localStorage.setItem(idKey, newId);
        }
      }

      setMsg("Encuesta guardada correctamente.");
    } catch (e: any) {
      console.error("SAVE_SURVEY_ERROR", e);
      setMsg(`Error guardando encuesta: ${extractGraphQLError(e)}`);
    } finally {
      setLoading(false);
    }
  }

  function renderInput(q: SurveyQuestion) {
    const val = answers[q.id];
    const showError = q.required && touched[q.id] && isEmpty(val);

    const base =
      "w-full rounded-xl border px-3 py-2 outline-none focus:ring-2";
    const border = showError
      ? "border-red-500 focus:ring-red-200"
      : "border-neutral-300 focus:ring-neutral-200";

    if (q.type === "text" || q.type === "currency") {
      return (
        <>
          <input
            className={`${base} ${border}`}
            value={typeof val === "string" ? val : ""}
            placeholder={q.placeholder ?? ""}
            inputMode={q.type === "currency" ? "decimal" : "text"}
            onChange={(e) =>
              setValue(
                q.id,
                q.type === "currency"
                  ? cleanCurrency(e.target.value)
                  : e.target.value
              )
            }
            onBlur={() => markTouched(q.id)}
          />
          {showError ? (
            <div className="mt-1 text-sm text-red-600">Obligatorio.</div>
          ) : null}
        </>
      );
    }

    if (q.type === "textarea") {
      return (
        <>
          <textarea
            className={`${base} ${border} min-h-[110px]`}
            value={typeof val === "string" ? val : ""}
            placeholder={q.placeholder ?? ""}
            onChange={(e) => setValue(q.id, e.target.value)}
            onBlur={() => markTouched(q.id)}
          />
